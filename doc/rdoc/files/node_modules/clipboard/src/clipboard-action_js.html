<!DOCTYPE html>
<html lang="en">
<head>
    <title>clipboard-action.js</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>
    <div class="banner">
        
        <h1>
            clipboard-action.js
        </h1>
        <ul class="files">
            
            <li>
                node_modules/clipboard/src/clipboard-action.js
                
            </li>
            <li>Last modified: 2018-11-21 17:20:08 -0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>import select from &#39;select&#39;;</p>

<pre><code>Inner class which performs selection from either `text` or `target`
properties and then executes copy or cut operations.
</code></pre>

<p>class ClipboardAction {</p>

<pre><code>/**
   @param {Object} options
  /
constructor(options) {
    this.resolveOptions(options);
    this.initSelection();
}

/**
   Defines base properties passed from constructor.
   @param {Object} options
  /
resolveOptions(options = {}) {
    this.action    = options.action;
    this.container = options.container;
    this.emitter   = options.emitter;
    this.target    = options.target;
    this.text      = options.text;
    this.trigger   = options.trigger;

    this.selectedText = &#39;&#39;;
}

/**
   Decides which selection strategy is going to be applied based
   on the existence of `text` and `target` properties.
  /
initSelection() {
    if (this.text) {
        this.selectFake();
    }
    else if (this.target) {
        this.selectTarget();
    }
}

/**
   Creates a fake textarea element, sets its value from `text` property,
   and makes a selection on it.
  /
selectFake() {
    const isRTL = document.documentElement.getAttribute(&#39;dir&#39;) == &#39;rtl&#39;;

    this.removeFake();

    this.fakeHandlerCallback = () =&gt; this.removeFake();
    this.fakeHandler = this.container.addEventListener(&#39;click&#39;, this.fakeHandlerCallback) || true;

    this.fakeElem = document.createElement(&#39;textarea&#39;);
    // Prevent zooming on iOS
    this.fakeElem.style.fontSize = &#39;12pt&#39;;
    // Reset box model
    this.fakeElem.style.border = &#39;0&#39;;
    this.fakeElem.style.padding = &#39;0&#39;;
    this.fakeElem.style.margin = &#39;0&#39;;
    // Move element out of screen horizontally
    this.fakeElem.style.position = &#39;absolute&#39;;
    this.fakeElem.style[ isRTL ? &#39;right&#39; : &#39;left&#39; ] = &#39;-9999px&#39;;
    // Move element to the same position vertically
    let yPosition = window.pageYOffset || document.documentElement.scrollTop;
    this.fakeElem.style.top = `${yPosition}px`;

    this.fakeElem.setAttribute(&#39;readonly&#39;, &#39;&#39;);
    this.fakeElem.value = this.text;

    this.container.appendChild(this.fakeElem);

    this.selectedText = select(this.fakeElem);
    this.copyText();
}

/**
   Only removes the fake element after another click event, that way
   a user can hit `Ctrl+C` to copy because selection still exists.
  /
removeFake() {
    if (this.fakeHandler) {
        this.container.removeEventListener(&#39;click&#39;, this.fakeHandlerCallback);
        this.fakeHandler = null;
        this.fakeHandlerCallback = null;
    }

    if (this.fakeElem) {
        this.container.removeChild(this.fakeElem);
        this.fakeElem = null;
    }
}

/**
   Selects the content from element passed on `target` property.
  /
selectTarget() {
    this.selectedText = select(this.target);
    this.copyText();
}

/**
   Executes the copy operation based on the current selection.
  /
copyText() {
    let succeeded;

    try {
        succeeded = document.execCommand(this.action);
    }
    catch (err) {
        succeeded = false;
    }

    this.handleResult(succeeded);
}

/**
   Fires an event based on the copy operation result.
   @param {Boolean} succeeded
  /
handleResult(succeeded) {
    this.emitter.emit(succeeded ? &#39;success&#39; : &#39;error&#39;, {
        action: this.action,
        text: this.selectedText,
        trigger: this.trigger,
        clearSelection: this.clearSelection.bind(this)
    });
}

/**
   Moves focus away from `target` and back to the trigger, removes current selection.
  /
clearSelection() {
    if (this.trigger) {
        this.trigger.focus();
    }

    window.getSelection().removeAllRanges();
}

/**
   Sets the `action` to be performed which can be either &#39;copy&#39; or &#39;cut&#39;.
   @param {String} action
  /
set action(action = &#39;copy&#39;) {
    this._action = action;

    if (this._action !== &#39;copy&#39; &amp;&amp; this._action !== &#39;cut&#39;) {
        throw new Error(&#39;Invalid &quot;action&quot; value, use either &quot;copy&quot; or &quot;cut&quot;&#39;);
    }
}

/**
   Gets the `action` property.
   @return {String}
  /
get action() {
    return this._action;
}

/**
   Sets the `target` property using an element
   that will be have its content copied.
   @param {Element} target
  /
set target(target) {
    if (target !== undefined) {
        if (target &amp;&amp; typeof target === &#39;object&#39; &amp;&amp; target.nodeType === 1) {
            if (this.action === &#39;copy&#39; &amp;&amp; target.hasAttribute(&#39;disabled&#39;)) {
                throw new Error(&#39;Invalid &quot;target&quot; attribute. Please use &quot;readonly&quot; instead of &quot;disabled&quot; attribute&#39;);
            }

            if (this.action === &#39;cut&#39; &amp;&amp; (target.hasAttribute(&#39;readonly&#39;) || target.hasAttribute(&#39;disabled&#39;))) {
                throw new Error(&#39;Invalid &quot;target&quot; attribute. You can\&#39;t cut text from elements with &quot;readonly&quot; or &quot;disabled&quot; attributes&#39;);
            }

            this._target = target;
        }
        else {
            throw new Error(&#39;Invalid &quot;target&quot; value, use a valid Element&#39;);
        }
    }
}

/**
   Gets the `target` property.
   @return {String|HTMLElement}
  /
get target() {
    return this._target;
}

/**
   Destroy lifecycle.
  /
destroy() {
    this.removeFake();
}
</code></pre>

<p>}</p>

<p>module.exports = ClipboardAction;</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </div>
  </body>
</html>
