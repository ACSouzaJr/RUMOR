<!DOCTYPE html>
<html lang="en">
<head>
    <title>clipboard.js</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>
    <div class="banner">
        
        <h1>
            clipboard.js
        </h1>
        <ul class="files">
            
            <li>
                node_modules/clipboard/dist/clipboard.js
                
            </li>
            <li>Last modified: 2018-11-21 17:20:08 -0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<pre><code>!
 clipboard.js v2.0.4
 https://zenorocha.github.io/clipboard.js

 Licensed MIT © Zeno Rocha
</code></pre>

<p>(function webpackUniversalModuleDefinition(root, factory) {</p>

<pre><code>if(typeof exports === &#39;object&#39; &amp;&amp; typeof module === &#39;object&#39;)
        module.exports = factory();
else if(typeof define === &#39;function&#39; &amp;&amp; define.amd)
        define([], factory);
else if(typeof exports === &#39;object&#39;)
        exports[&quot;ClipboardJS&quot;] = factory();
else
        root[&quot;ClipboardJS&quot;] = factory();
</code></pre>

<p>})(this, function() { return        / (function(modules) { //
webpackBootstrap /               // The module cache /******/        var
installedModules = {}; /******/ /******/        // The require function
/******/        function <em>webpack_require</em>(moduleId) { /******/
/******/                // Check if module is in cache /******/            
<a href="moduleId">if(installedModules</a>) { /******/                     
return <a href="moduleId">installedModules</a>.exports; /******/           
} /******/                // Create a new module (and put it into the
cache) /******/                var module = <a
href="moduleId">installedModules</a> = { /******/                        i:
moduleId, /******/                        l: false, /******/               
exports: {} /******/                }; /******/ /******/                //
Execute the module function /******/                <a
href="moduleId">modules</a>.call(module.exports, module, module.exports,
<em>webpack_require</em>); /******/ /******/                // Flag the
module as loaded /******/                module.l = true; /******/ /******/
// Return the exports of the module /******/                return
module.exports; /******/        } /******/ /******/ /******/        //
expose the modules object (<em>webpack_modules</em>) /******/       
<em>webpack_require</em>.m = modules; /******/ /******/        // expose
the module cache /******/        <em>webpack_require</em>.c =
installedModules; /******/ /******/        // define getter function for
harmony exports /******/        <em>webpack_require</em>.d =
function(exports, name, getter) { /******/               
if(!<em>webpack_require</em>.o(exports, name)) { /******/                  
Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/                } /******/        }; /******/ /******/        //
define __esModule on exports /******/        <em>webpack_require</em>.r =
function(exports) { /******/                if(typeof Symbol !==
&#39;undefined&#39; &amp;&amp; Symbol.toStringTag) { /******/              
Object.defineProperty(exports, Symbol.toStringTag, { value:
&#39;Module&#39; }); /******/                } /******/               
Object.defineProperty(exports, &#39;__esModule&#39;, { value: true });
/******/        }; /******/ /******/        // create a fake namespace
object /******/        // mode &amp; 1: value is a module id, require it
/******/        // mode &amp; 2: merge all properties of value into the ns
/******/        // mode &amp; 4: return value when already ns object
/******/        // mode &amp; 8|1: behave like require /******/       
<em>webpack_require</em>.t = function(value, mode) { /******/              
if(mode &amp; 1) value = <em>webpack_require</em>(value); /******/         
if(mode &amp; 8) return value; /******/                if((mode &amp; 4)
&amp;&amp; typeof value === &#39;object&#39; &amp;&amp; value &amp;&amp;
value.__esModule) return value; /******/                var ns =
Object.create(null); /******/               
<em>webpack_require</em>.r(ns); /******/               
Object.defineProperty(ns, &#39;default&#39;, { enumerable: true, value:
value }); /******/                if(mode &amp; 2 &amp;&amp; typeof value
!= &#39;string&#39;) for(var key in value) <em>webpack_require</em>.d(ns,
key, function(key) { return <a href="key">value</a>; }.bind(null, key));
/******/                return ns; /******/        }; /******/ /******/    
// getDefaultExport function for compatibility with non-harmony modules
/******/        <em>webpack_require</em>.n = function(module) { /******/   
var getter = module &amp;&amp; module.__esModule ? /******/                
function getDefault() { return <a href="'default'">module</a>; } : /******/
function getModuleExports() { return module; }; /******/               
<em>webpack_require</em>.d(getter, &#39;a&#39;, getter); /******/          
return getter; /******/        }; /******/ /******/        //
Object.prototype.hasOwnProperty.call /******/       
<em>webpack_require</em>.o = function(object, property) { return
Object.prototype.hasOwnProperty.call(object, property); }; /******/
/******/        // <em>webpack_public_path</em> /******/       
<em>webpack_require</em>.p = “”; /******/ /******/ /******/        // Load
entry module and return exports /******/        return
<em>webpack_require</em>(<em>webpack_require</em>.s = 0); /******/ })
/************************************************************************/
/******/ ([ /* 0 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>“use strict”;</p>

<p>var _typeof = typeof Symbol === “function” &amp;&amp; typeof
Symbol.iterator === “symbol” ? function (obj) { return typeof obj; } :
function (obj) { return obj &amp;&amp; typeof Symbol === “function”
&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ?
“symbol” : typeof obj; };</p>

<p>var _createClass = function () { function defineProperties(target, props) {
for (var i = 0; i &lt; props.length; i++) { var descriptor = <a
href="i">props</a>; descriptor.enumerable = descriptor.enumerable || false;
descriptor.configurable = true; if (“value” in descriptor)
descriptor.writable = true; Object.defineProperty(target, descriptor.key,
descriptor); } } return function (Constructor, protoProps, staticProps) {
if (protoProps) defineProperties(Constructor.prototype, protoProps); if
(staticProps) defineProperties(Constructor, staticProps); return
Constructor; }; }();</p>

<p>var _clipboardAction = <em>webpack_require</em>(1);</p>

<p>var _clipboardAction2 = _interopRequireDefault(_clipboardAction);</p>

<p>var _tinyEmitter = <em>webpack_require</em>(3);</p>

<p>var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);</p>

<p>var _goodListener = <em>webpack_require</em>(4);</p>

<p>var _goodListener2 = _interopRequireDefault(_goodListener);</p>

<p>function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule
? obj : { default: obj }; }</p>

<p>function _classCallCheck(instance, Constructor) { if (!(instance instanceof
Constructor)) { throw new TypeError(“Cannot call a class as a function”); }
}</p>

<p>function _possibleConstructorReturn(self, call) { if (!self) { throw new
ReferenceError(“this hasn&#39;t been initialised - super() hasn&#39;t been
called”); } return call &amp;&amp; (typeof call === “object” || typeof call
=== “function”) ? call : self; }</p>

<p>function _inherits(subClass, superClass) { if (typeof superClass !==
“function” &amp;&amp; superClass !== null) { throw new TypeError(“Super
expression must either be null or a function, not ” + typeof superClass); }
subClass.prototype = Object.create(superClass &amp;&amp;
superClass.prototype, { constructor: { value: subClass, enumerable: false,
writable: true, configurable: true } }); if (superClass)
Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) :
subClass.__proto__ = superClass; }</p>

<p>/**</p>

<pre><code> Base class which takes one or more elements, adds event listeners to them,
 and instantiates a new `ClipboardAction` on each click.
/
</code></pre>

<p>var Clipboard = function (_Emitter) {</p>

<pre><code>_inherits(Clipboard, _Emitter);

/**
   @param {String|HTMLElement|HTMLCollection|NodeList} trigger
   @param {Object} options
  /
function Clipboard(trigger, options) {
    _classCallCheck(this, Clipboard);

    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));

    _this.resolveOptions(options);
    _this.listenClick(trigger);
    return _this;
}

/**
   Defines if attributes would be resolved using internal setter functions
   or custom functions that were passed in the constructor.
   @param {Object} options
  /

_createClass(Clipboard, [{
    key: &#39;resolveOptions&#39;,
    value: function resolveOptions() {
        var options = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};

        this.action = typeof options.action === &#39;function&#39; ? options.action : this.defaultAction;
        this.target = typeof options.target === &#39;function&#39; ? options.target : this.defaultTarget;
        this.text = typeof options.text === &#39;function&#39; ? options.text : this.defaultText;
        this.container = _typeof(options.container) === &#39;object&#39; ? options.container : document.body;
    }

    /**
       Adds a click event listener to the passed trigger.
       @param {String|HTMLElement|HTMLCollection|NodeList} trigger
      /

}, {
    key: &#39;listenClick&#39;,
    value: function listenClick(trigger) {
        var _this2 = this;

        this.listener = (0, _goodListener2.default)(trigger, &#39;click&#39;, function (e) {
            return _this2.onClick(e);
        });
    }

    /**
       Defines a new `ClipboardAction` on each click event.
       @param {Event} e
      /

}, {
    key: &#39;onClick&#39;,
    value: function onClick(e) {
        var trigger = e.delegateTarget || e.currentTarget;

        if (this.clipboardAction) {
            this.clipboardAction = null;
        }

        this.clipboardAction = new _clipboardAction2.default({
            action: this.action(trigger),
            target: this.target(trigger),
            text: this.text(trigger),
            container: this.container,
            trigger: trigger,
            emitter: this
        });
    }

    /**
       Default `action` lookup function.
       @param {Element} trigger
      /

}, {
    key: &#39;defaultAction&#39;,
    value: function defaultAction(trigger) {
        return getAttributeValue(&#39;action&#39;, trigger);
    }

    /**
       Default `target` lookup function.
       @param {Element} trigger
      /

}, {
    key: &#39;defaultTarget&#39;,
    value: function defaultTarget(trigger) {
        var selector = getAttributeValue(&#39;target&#39;, trigger);

        if (selector) {
            return document.querySelector(selector);
        }
    }

    /**
       Returns the support of the given action, or all actions if no action is
       given.
       @param {String} [action]
      /

}, {
    key: &#39;defaultText&#39;,

    /**
       Default `text` lookup function.
       @param {Element} trigger
      /
    value: function defaultText(trigger) {
        return getAttributeValue(&#39;text&#39;, trigger);
    }

    /**
       Destroy lifecycle.
      /

}, {
    key: &#39;destroy&#39;,
    value: function destroy() {
        this.listener.destroy();

        if (this.clipboardAction) {
            this.clipboardAction.destroy();
            this.clipboardAction = null;
        }
    }
}], [{
    key: &#39;isSupported&#39;,
    value: function isSupported() {
        var action = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : [&#39;copy&#39;, &#39;cut&#39;];

        var actions = typeof action === &#39;string&#39; ? [action] : action;
        var support = !!document.queryCommandSupported;

        actions.forEach(function (action) {
            support = support &amp;&amp; !!document.queryCommandSupported(action);
        });

        return support;
    }
}]);

return Clipboard;
</code></pre>

<p>}(_tinyEmitter2.default);</p>

<p>/**</p>

<pre><code> Helper function to retrieve attribute value.
 @param {String} suffix
 @param {Element} element
/
</code></pre>

<p>function getAttributeValue(suffix, element) {</p>

<pre><code>var attribute = &#39;data-clipboard-&#39; + suffix;

if (!element.hasAttribute(attribute)) {
    return;
}

return element.getAttribute(attribute);
</code></pre>

<p>}</p>

<p>module.exports = Clipboard;</p>

<p>/***/ }), /* 1 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>“use strict”;</p>

<p>var _typeof = typeof Symbol === “function” &amp;&amp; typeof
Symbol.iterator === “symbol” ? function (obj) { return typeof obj; } :
function (obj) { return obj &amp;&amp; typeof Symbol === “function”
&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ?
“symbol” : typeof obj; };</p>

<p>var _createClass = function () { function defineProperties(target, props) {
for (var i = 0; i &lt; props.length; i++) { var descriptor = <a
href="i">props</a>; descriptor.enumerable = descriptor.enumerable || false;
descriptor.configurable = true; if (“value” in descriptor)
descriptor.writable = true; Object.defineProperty(target, descriptor.key,
descriptor); } } return function (Constructor, protoProps, staticProps) {
if (protoProps) defineProperties(Constructor.prototype, protoProps); if
(staticProps) defineProperties(Constructor, staticProps); return
Constructor; }; }();</p>

<p>var _select = <em>webpack_require</em>(2);</p>

<p>var _select2 = _interopRequireDefault(_select);</p>

<p>function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule
? obj : { default: obj }; }</p>

<p>function _classCallCheck(instance, Constructor) { if (!(instance instanceof
Constructor)) { throw new TypeError(“Cannot call a class as a function”); }
}</p>

<p>/**</p>

<pre><code> Inner class which performs selection from either `text` or `target`
 properties and then executes copy or cut operations.
/
</code></pre>

<p>var ClipboardAction = function () {</p>

<pre><code>/**
   @param {Object} options
  /
function ClipboardAction(options) {
    _classCallCheck(this, ClipboardAction);

    this.resolveOptions(options);
    this.initSelection();
}

/**
   Defines base properties passed from constructor.
   @param {Object} options
  /

_createClass(ClipboardAction, [{
    key: &#39;resolveOptions&#39;,
    value: function resolveOptions() {
        var options = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};

        this.action = options.action;
        this.container = options.container;
        this.emitter = options.emitter;
        this.target = options.target;
        this.text = options.text;
        this.trigger = options.trigger;

        this.selectedText = &#39;&#39;;
    }

    /**
       Decides which selection strategy is going to be applied based
       on the existence of `text` and `target` properties.
      /

}, {
    key: &#39;initSelection&#39;,
    value: function initSelection() {
        if (this.text) {
            this.selectFake();
        } else if (this.target) {
            this.selectTarget();
        }
    }

    /**
       Creates a fake textarea element, sets its value from `text` property,
       and makes a selection on it.
      /

}, {
    key: &#39;selectFake&#39;,
    value: function selectFake() {
        var _this = this;

        var isRTL = document.documentElement.getAttribute(&#39;dir&#39;) == &#39;rtl&#39;;

        this.removeFake();

        this.fakeHandlerCallback = function () {
            return _this.removeFake();
        };
        this.fakeHandler = this.container.addEventListener(&#39;click&#39;, this.fakeHandlerCallback) || true;

        this.fakeElem = document.createElement(&#39;textarea&#39;);
        // Prevent zooming on iOS
        this.fakeElem.style.fontSize = &#39;12pt&#39;;
        // Reset box model
        this.fakeElem.style.border = &#39;0&#39;;
        this.fakeElem.style.padding = &#39;0&#39;;
        this.fakeElem.style.margin = &#39;0&#39;;
        // Move element out of screen horizontally
        this.fakeElem.style.position = &#39;absolute&#39;;
        this.fakeElem.style[isRTL ? &#39;right&#39; : &#39;left&#39;] = &#39;-9999px&#39;;
        // Move element to the same position vertically
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        this.fakeElem.style.top = yPosition + &#39;px&#39;;

        this.fakeElem.setAttribute(&#39;readonly&#39;, &#39;&#39;);
        this.fakeElem.value = this.text;

        this.container.appendChild(this.fakeElem);

        this.selectedText = (0, _select2.default)(this.fakeElem);
        this.copyText();
    }

    /**
       Only removes the fake element after another click event, that way
       a user can hit `Ctrl+C` to copy because selection still exists.
      /

}, {
    key: &#39;removeFake&#39;,
    value: function removeFake() {
        if (this.fakeHandler) {
            this.container.removeEventListener(&#39;click&#39;, this.fakeHandlerCallback);
            this.fakeHandler = null;
            this.fakeHandlerCallback = null;
        }

        if (this.fakeElem) {
            this.container.removeChild(this.fakeElem);
            this.fakeElem = null;
        }
    }

    /**
       Selects the content from element passed on `target` property.
      /

}, {
    key: &#39;selectTarget&#39;,
    value: function selectTarget() {
        this.selectedText = (0, _select2.default)(this.target);
        this.copyText();
    }

    /**
       Executes the copy operation based on the current selection.
      /

}, {
    key: &#39;copyText&#39;,
    value: function copyText() {
        var succeeded = void 0;

        try {
            succeeded = document.execCommand(this.action);
        } catch (err) {
            succeeded = false;
        }

        this.handleResult(succeeded);
    }

    /**
       Fires an event based on the copy operation result.
       @param {Boolean} succeeded
      /

}, {
    key: &#39;handleResult&#39;,
    value: function handleResult(succeeded) {
        this.emitter.emit(succeeded ? &#39;success&#39; : &#39;error&#39;, {
            action: this.action,
            text: this.selectedText,
            trigger: this.trigger,
            clearSelection: this.clearSelection.bind(this)
        });
    }

    /**
       Moves focus away from `target` and back to the trigger, removes current selection.
      /

}, {
    key: &#39;clearSelection&#39;,
    value: function clearSelection() {
        if (this.trigger) {
            this.trigger.focus();
        }

        window.getSelection().removeAllRanges();
    }

    /**
       Sets the `action` to be performed which can be either &#39;copy&#39; or &#39;cut&#39;.
       @param {String} action
      /

}, {
    key: &#39;destroy&#39;,

    /**
       Destroy lifecycle.
      /
    value: function destroy() {
        this.removeFake();
    }
}, {
    key: &#39;action&#39;,
    set: function set() {
        var action = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : &#39;copy&#39;;

        this._action = action;

        if (this._action !== &#39;copy&#39; &amp;&amp; this._action !== &#39;cut&#39;) {
            throw new Error(&#39;Invalid &quot;action&quot; value, use either &quot;copy&quot; or &quot;cut&quot;&#39;);
        }
    }

    /**
       Gets the `action` property.
       @return {String}
      /
    ,
    get: function get() {
        return this._action;
    }

    /**
       Sets the `target` property using an element
       that will be have its content copied.
       @param {Element} target
      /

}, {
    key: &#39;target&#39;,
    set: function set(target) {
        if (target !== undefined) {
            if (target &amp;&amp; (typeof target === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(target)) === &#39;object&#39; &amp;&amp; target.nodeType === 1) {
                if (this.action === &#39;copy&#39; &amp;&amp; target.hasAttribute(&#39;disabled&#39;)) {
                    throw new Error(&#39;Invalid &quot;target&quot; attribute. Please use &quot;readonly&quot; instead of &quot;disabled&quot; attribute&#39;);
                }

                if (this.action === &#39;cut&#39; &amp;&amp; (target.hasAttribute(&#39;readonly&#39;) || target.hasAttribute(&#39;disabled&#39;))) {
                    throw new Error(&#39;Invalid &quot;target&quot; attribute. You can\&#39;t cut text from elements with &quot;readonly&quot; or &quot;disabled&quot; attributes&#39;);
                }

                this._target = target;
            } else {
                throw new Error(&#39;Invalid &quot;target&quot; value, use a valid Element&#39;);
            }
        }
    }

    /**
       Gets the `target` property.
       @return {String|HTMLElement}
      /
    ,
    get: function get() {
        return this._target;
    }
}]);

return ClipboardAction;
</code></pre>

<p>}();</p>

<p>module.exports = ClipboardAction;</p>

<p>/***/ }), /* 2 */ /***/ (function(module, exports) {</p>

<p>function select(element) {</p>

<pre><code>var selectedText;

if (element.nodeName === &#39;SELECT&#39;) {
    element.focus();

    selectedText = element.value;
}
else if (element.nodeName === &#39;INPUT&#39; || element.nodeName === &#39;TEXTAREA&#39;) {
    var isReadOnly = element.hasAttribute(&#39;readonly&#39;);

    if (!isReadOnly) {
        element.setAttribute(&#39;readonly&#39;, &#39;&#39;);
    }

    element.select();
    element.setSelectionRange(0, element.value.length);

    if (!isReadOnly) {
        element.removeAttribute(&#39;readonly&#39;);
    }

    selectedText = element.value;
}
else {
    if (element.hasAttribute(&#39;contenteditable&#39;)) {
        element.focus();
    }

    var selection = window.getSelection();
    var range = document.createRange();

    range.selectNodeContents(element);
    selection.removeAllRanges();
    selection.addRange(range);

    selectedText = selection.toString();
}

return selectedText;
</code></pre>

<p>}</p>

<p>module.exports = select;</p>

<p>/***/ }), /* 3 */ /***/ (function(module, exports) {</p>

<p>function E () {</p>

<pre><code>// Keep this empty so it&#39;s easier to inherit from
// (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
</code></pre>

<p>}</p>

<p>E.prototype = {</p>

<pre><code>on: function (name, callback, ctx) {
  var e = this.e || (this.e = {});

  (e[name] || (e[name] = [])).push({
    fn: callback,
    ctx: ctx
  });

  return this;
},

once: function (name, callback, ctx) {
  var self = this;
  function listener () {
    self.off(name, listener);
    callback.apply(ctx, arguments);
  };

  listener._ = callback
  return this.on(name, listener, ctx);
},

emit: function (name) {
  var data = [].slice.call(arguments, 1);
  var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
  var i = 0;
  var len = evtArr.length;

  for (i; i &lt; len; i++) {
    evtArr[i].fn.apply(evtArr[i].ctx, data);
  }

  return this;
},

off: function (name, callback) {
  var e = this.e || (this.e = {});
  var evts = e[name];
  var liveEvents = [];

  if (evts &amp;&amp; callback) {
    for (var i = 0, len = evts.length; i &lt; len; i++) {
      if (evts[i].fn !== callback &amp;&amp; evts[i].fn._ !== callback)
        liveEvents.push(evts[i]);
    }
  }

  // Remove event from queue to prevent memory leak
  // Suggested by https://github.com/lazd
  // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

  (liveEvents.length)
    ? e[name] = liveEvents
    : delete e[name];

  return this;
}
</code></pre>

<p>};</p>

<p>module.exports = E;</p>

<p>/***/ }), /* 4 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>var is = <em>webpack_require</em>(5); var delegate =
<em>webpack_require</em>(6);</p>

<p>/**</p>

<pre><code> Validates all params and calls the right
 listener function based on its target type.

 @param {String|HTMLElement|HTMLCollection|NodeList} target
 @param {String} type
 @param {Function} callback
 @return {Object}
/
</code></pre>

<p>function listen(target, type, callback) {</p>

<pre><code>if (!target &amp;&amp; !type &amp;&amp; !callback) {
    throw new Error(&#39;Missing required arguments&#39;);
}

if (!is.string(type)) {
    throw new TypeError(&#39;Second argument must be a String&#39;);
}

if (!is.fn(callback)) {
    throw new TypeError(&#39;Third argument must be a Function&#39;);
}

if (is.node(target)) {
    return listenNode(target, type, callback);
}
else if (is.nodeList(target)) {
    return listenNodeList(target, type, callback);
}
else if (is.string(target)) {
    return listenSelector(target, type, callback);
}
else {
    throw new TypeError(&#39;First argument must be a String, HTMLElement, HTMLCollection, or NodeList&#39;);
}
</code></pre>

<p>}</p>

<p>/**</p>

<pre><code> Adds an event listener to a HTML element
 and returns a remove listener function.

 @param {HTMLElement} node
 @param {String} type
 @param {Function} callback
 @return {Object}
/
</code></pre>

<p>function listenNode(node, type, callback) {</p>

<pre><code>node.addEventListener(type, callback);

return {
    destroy: function() {
        node.removeEventListener(type, callback);
    }
}
</code></pre>

<p>}</p>

<p>/**</p>

<pre><code> Add an event listener to a list of HTML elements
 and returns a remove listener function.

 @param {NodeList|HTMLCollection} nodeList
 @param {String} type
 @param {Function} callback
 @return {Object}
/
</code></pre>

<p>function listenNodeList(nodeList, type, callback) {</p>

<pre><code>Array.prototype.forEach.call(nodeList, function(node) {
    node.addEventListener(type, callback);
});

return {
    destroy: function() {
        Array.prototype.forEach.call(nodeList, function(node) {
            node.removeEventListener(type, callback);
        });
    }
}
</code></pre>

<p>}</p>

<p>/**</p>

<pre><code> Add an event listener to a selector
 and returns a remove listener function.

 @param {String} selector
 @param {String} type
 @param {Function} callback
 @return {Object}
/
</code></pre>

<p>function listenSelector(selector, type, callback) {</p>

<pre><code>return delegate(document.body, selector, type, callback);
</code></pre>

<p>}</p>

<p>module.exports = listen;</p>

<p>/***/ }), /* 5 */ /***/ (function(module, exports) {</p>

<p>/**</p>

<pre><code> Check if argument is a HTML element.

 @param {Object} value
 @return {Boolean}
/
</code></pre>

<p>exports.node = function(value) {</p>

<pre><code>return value !== undefined
    &amp;&amp; value instanceof HTMLElement
    &amp;&amp; value.nodeType === 1;
</code></pre>

<p>};</p>

<p>/**</p>

<pre><code> Check if argument is a list of HTML elements.

 @param {Object} value
 @return {Boolean}
/
</code></pre>

<p>exports.nodeList = function(value) {</p>

<pre><code>var type = Object.prototype.toString.call(value);

return value !== undefined
    &amp;&amp; (type === &#39;[object NodeList]&#39; || type === &#39;[object HTMLCollection]&#39;)
    &amp;&amp; (&#39;length&#39; in value)
    &amp;&amp; (value.length === 0 || exports.node(value[0]));
</code></pre>

<p>};</p>

<p>/**</p>

<pre><code> Check if argument is a string.

 @param {Object} value
 @return {Boolean}
/
</code></pre>

<p>exports.string = function(value) {</p>

<pre><code>return typeof value === &#39;string&#39;
    || value instanceof String;
</code></pre>

<p>};</p>

<p>/**</p>

<pre><code> Check if argument is a function.

 @param {Object} value
 @return {Boolean}
/
</code></pre>

<p>exports.fn = function(value) {</p>

<pre><code>var type = Object.prototype.toString.call(value);

return type === &#39;[object Function]&#39;;
</code></pre>

<p>};</p>

<p>/***/ }), /* 6 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>var closest = <em>webpack_require</em>(7);</p>

<p>/**</p>

<pre><code> Delegates event to a selector.

 @param {Element} element
 @param {String} selector
 @param {String} type
 @param {Function} callback
 @param {Boolean} useCapture
 @return {Object}
/
</code></pre>

<p>function _delegate(element, selector, type, callback, useCapture) {</p>

<pre><code>var listenerFn = listener.apply(this, arguments);

element.addEventListener(type, listenerFn, useCapture);

return {
    destroy: function() {
        element.removeEventListener(type, listenerFn, useCapture);
    }
}
</code></pre>

<p>}</p>

<p>/**</p>

<pre><code> Delegates event to a selector.

 @param {Element|String|Array} [elements]
 @param {String} selector
 @param {String} type
 @param {Function} callback
 @param {Boolean} useCapture
 @return {Object}
/
</code></pre>

<p>function delegate(elements, selector, type, callback, useCapture) {</p>

<pre><code>// Handle the regular Element usage
if (typeof elements.addEventListener === &#39;function&#39;) {
    return _delegate.apply(null, arguments);
}

// Handle Element-less usage, it defaults to global delegation
if (typeof type === &#39;function&#39;) {
    // Use `document` as the first parameter, then apply arguments
    // This is a short way to .unshift `arguments` without running into deoptimizations
    return _delegate.bind(null, document).apply(null, arguments);
}

// Handle Selector-based usage
if (typeof elements === &#39;string&#39;) {
    elements = document.querySelectorAll(elements);
}

// Handle Array-like based usage
return Array.prototype.map.call(elements, function (element) {
    return _delegate(element, selector, type, callback, useCapture);
});
</code></pre>

<p>}</p>

<p>/**</p>

<pre><code> Finds closest match and invokes callback.

 @param {Element} element
 @param {String} selector
 @param {String} type
 @param {Function} callback
 @return {Function}
/
</code></pre>

<p>function listener(element, selector, type, callback) {</p>

<pre><code>return function(e) {
    e.delegateTarget = closest(e.target, selector);

    if (e.delegateTarget) {
        callback.call(element, e);
    }
}
</code></pre>

<p>}</p>

<p>module.exports = delegate;</p>

<p>/***/ }), /* 7 */ /***/ (function(module, exports) {</p>

<p>var DOCUMENT_NODE_TYPE = 9;</p>

<p>/**</p>

<pre><code> A polyfill for Element.matches()
/
</code></pre>

<p>if (typeof Element !== &#39;undefined&#39; &amp;&amp;
!Element.prototype.matches) {</p>

<pre><code>var proto = Element.prototype;

proto.matches = proto.matchesSelector ||
                proto.mozMatchesSelector ||
                proto.msMatchesSelector ||
                proto.oMatchesSelector ||
                proto.webkitMatchesSelector;
</code></pre>

<p>}</p>

<p>/**</p>

<pre><code> Finds the closest parent that matches a selector.

 @param {Element} element
 @param {String} selector
 @return {Function}
/
</code></pre>

<p>function closest (element, selector) {</p>

<pre><code>while (element &amp;&amp; element.nodeType !== DOCUMENT_NODE_TYPE) {
    if (typeof element.matches === &#39;function&#39; &amp;&amp;
        element.matches(selector)) {
      return element;
    }
    element = element.parentNode;
}
</code></pre>

<p>}</p>

<p>module.exports = closest;</p>

<p>/***/ }) /******/ ]); });</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </div>
  </body>
</html>
